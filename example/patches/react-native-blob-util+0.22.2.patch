diff --git a/node_modules/react-native-blob-util/android/src/main/java/com/ReactNativeBlobUtil/ReactNativeBlobUtilReq.java b/node_modules/react-native-blob-util/android/src/main/java/com/ReactNativeBlobUtil/ReactNativeBlobUtilReq.java
index ddf5adb..4701546 100644
--- a/node_modules/react-native-blob-util/android/src/main/java/com/ReactNativeBlobUtil/ReactNativeBlobUtilReq.java
+++ b/node_modules/react-native-blob-util/android/src/main/java/com/ReactNativeBlobUtil/ReactNativeBlobUtilReq.java
@@ -754,15 +754,6 @@ public class ReactNativeBlobUtilReq extends BroadcastReceiver implements Runnabl
             case FileStorage:
                 ResponseBody responseBody = resp.body();
 
-                try {
-                    // In order to write response data to `destPath` we have to invoke this method.
-                    // It uses customized response body which is able to report download progress
-                    // and write response data to destination path.
-                    responseBody.bytes();
-                } catch (Exception ignored) {
-//                    ignored.printStackTrace();
-                }
-
                 ReactNativeBlobUtilFileResp ReactNativeBlobUtilFileResp;
 
                 try {
@@ -787,6 +778,13 @@ public class ReactNativeBlobUtilReq extends BroadcastReceiver implements Runnabl
                     return;
                 }
 
+                try {
+                    ReactNativeBlobUtilFileResp.writeToFile();
+                } catch (IOException ioException) {
+                    invoke_callback("Failed to save file: " + ioException.getLocalizedMessage(), respmap.copy());
+                    return;
+                }
+
                 if (ReactNativeBlobUtilFileResp != null && !ReactNativeBlobUtilFileResp.isDownloadComplete()) {
                     invoke_callback("Download interrupted.", respmap.copy());
                 } else {
diff --git a/node_modules/react-native-blob-util/android/src/main/java/com/ReactNativeBlobUtil/Response/ReactNativeBlobUtilFileResp.java b/node_modules/react-native-blob-util/android/src/main/java/com/ReactNativeBlobUtil/Response/ReactNativeBlobUtilFileResp.java
index 8291b84..5d41d8a 100644
--- a/node_modules/react-native-blob-util/android/src/main/java/com/ReactNativeBlobUtil/Response/ReactNativeBlobUtilFileResp.java
+++ b/node_modules/react-native-blob-util/android/src/main/java/com/ReactNativeBlobUtil/Response/ReactNativeBlobUtilFileResp.java
@@ -13,6 +13,7 @@ import com.facebook.react.modules.core.DeviceEventManagerModule;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.io.InputStream;
 
 import okhttp3.MediaType;
 import okhttp3.ResponseBody;
@@ -34,10 +35,13 @@ public class ReactNativeBlobUtilFileResp extends ResponseBody {
     ReactApplicationContext rctContext;
     FileOutputStream ofStream;
     boolean isEndMarkerReceived;
+    InputStream inputStream;
+    private static final int STREAM_BUFFER_SIZE = 64 * 1024;
 
     public ReactNativeBlobUtilFileResp(ResponseBody body) {
         super();
         this.originalBody = body;
+        this.inputStream = body.byteStream();
     }
 
     public ReactNativeBlobUtilFileResp(ReactApplicationContext ctx, String taskId, ResponseBody body, String path, boolean overwrite) throws IOException {
@@ -48,6 +52,7 @@ public class ReactNativeBlobUtilFileResp extends ResponseBody {
         assert path != null;
         this.mPath = path;
         this.isEndMarkerReceived = false;
+        this.inputStream = body.byteStream();
         if (path != null) {
             boolean appendToExistingFile = !overwrite;
             path = path.replace("?append=true", "");
@@ -65,6 +70,32 @@ public class ReactNativeBlobUtilFileResp extends ResponseBody {
         }
     }
 
+    public void writeToFile() throws IOException {
+        InputStream stream = inputStream;
+        if (stream == null) {
+            stream = originalBody.byteStream();
+            inputStream = stream;
+        }
+
+        byte[] buffer = new byte[STREAM_BUFFER_SIZE];
+        int read;
+        try {
+            while ((read = stream.read(buffer)) != -1) {
+                if (read <= 0) {
+                    continue;
+                }
+                ofStream.write(buffer, 0, read);
+                bytesDownloaded += read;
+                maybeReportProgress();
+            }
+            isEndMarkerReceived = true;
+            maybeReportProgress();
+            ofStream.flush();
+        } finally {
+            closeStreams();
+        }
+    }
+
     @Override
     public MediaType contentType() {
         return originalBody.contentType();
@@ -89,8 +120,9 @@ public class ReactNativeBlobUtilFileResp extends ResponseBody {
     }
 
     public boolean isDownloadComplete() {
-        return (bytesDownloaded == contentLength()) // Case of non-chunked downloads
-                || (contentLength() == -1 && isEndMarkerReceived); // Case of chunked downloads
+        long expectedLength = contentLength();
+        return (expectedLength >= 0 && bytesDownloaded >= expectedLength)
+                || (expectedLength == -1 && isEndMarkerReceived);
     }
 
     @Override
@@ -103,38 +135,22 @@ public class ReactNativeBlobUtilFileResp extends ResponseBody {
         @Override
         public long read(@NonNull Buffer sink, long byteCount) throws IOException {
             try {
-                byte[] bytes = new byte[(int) byteCount];
-                long read = originalBody.byteStream().read(bytes, 0, (int) byteCount);
-                bytesDownloaded += read > 0 ? read : 0;
+                int limit = (int) Math.min(byteCount, STREAM_BUFFER_SIZE);
+                if (limit <= 0) {
+                    limit = STREAM_BUFFER_SIZE;
+                }
+                byte[] bytes = new byte[limit];
+                int read = inputStream != null ? inputStream.read(bytes, 0, limit) : -1;
+
                 if (read > 0) {
-                    ofStream.write(bytes, 0, (int) read);
-                } else if (contentLength() == -1 && read == -1) {
-                    // End marker has been received for chunked download
+                    ofStream.write(bytes, 0, read);
+                    sink.write(bytes, 0, read);
+                    bytesDownloaded += read;
+                } else if (read == -1) {
                     isEndMarkerReceived = true;
                 }
-                ReactNativeBlobUtilProgressConfig reportConfig = ReactNativeBlobUtilReq.getReportProgress(mTaskId);
-
-                if (contentLength() != 0) {
-
-                    // For non-chunked download, progress is received / total
-                    // For chunked download, progress can be either 0 (started) or 1 (ended)
-                    float progress = (contentLength() != -1) ? bytesDownloaded / contentLength() : ((isEndMarkerReceived) ? 1 : 0);
-
-                    if (reportConfig != null && reportConfig.shouldReport(progress /* progress */)) {
-                        if (contentLength() != -1) {
-                            // For non-chunked downloads
-                            reportProgress(mTaskId, bytesDownloaded, contentLength());
-                        } else {
-                            // For chunked downloads
-                            if (!isEndMarkerReceived) {
-                                reportProgress(mTaskId, 0, contentLength());
-                            } else {
-                                reportProgress(mTaskId, bytesDownloaded, bytesDownloaded);
-                            }
-                        }
-                    }
 
-                }
+                maybeReportProgress();
 
                 return read;
             } catch (Exception ex) {
@@ -142,15 +158,6 @@ public class ReactNativeBlobUtilFileResp extends ResponseBody {
             }
         }
 
-        private void reportProgress(String taskId, long bytesDownloaded, long contentLength) {
-            WritableMap args = Arguments.createMap();
-            args.putString("taskId", taskId);
-            args.putString("written", String.valueOf(bytesDownloaded));
-            args.putString("total", String.valueOf(contentLength));
-            rctContext.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)
-                    .emit(ReactNativeBlobUtilConst.EVENT_PROGRESS, args);
-        }
-
         @Override
         public Timeout timeout() {
             return null;
@@ -158,9 +165,59 @@ public class ReactNativeBlobUtilFileResp extends ResponseBody {
 
         @Override
         public void close() throws IOException {
-            ofStream.close();
+            closeStreams();
 
         }
     }
 
+    private void closeStreams() throws IOException {
+        try {
+            if (ofStream != null) {
+                ofStream.close();
+                ofStream = null;
+            }
+        } finally {
+            if (inputStream != null) {
+                inputStream.close();
+                inputStream = null;
+            }
+        }
+    }
+
+    private void maybeReportProgress() {
+        ReactNativeBlobUtilProgressConfig reportConfig = ReactNativeBlobUtilReq.getReportProgress(mTaskId);
+        long total = contentLength();
+
+        if (reportConfig == null || total == 0) {
+            return;
+        }
+
+        float progress = (total != -1)
+                ? ((float) bytesDownloaded) / (float) total
+                : (isEndMarkerReceived ? 1f : 0f);
+
+        if (!reportConfig.shouldReport(progress)) {
+            return;
+        }
+
+        if (total != -1) {
+            emitProgressEvent(bytesDownloaded, total);
+        } else {
+            if (!isEndMarkerReceived) {
+                emitProgressEvent(0, total);
+            } else {
+                emitProgressEvent(bytesDownloaded, bytesDownloaded);
+            }
+        }
+    }
+
+    private void emitProgressEvent(long written, long total) {
+        WritableMap args = Arguments.createMap();
+        args.putString("taskId", mTaskId);
+        args.putString("written", String.valueOf(written));
+        args.putString("total", String.valueOf(total));
+        rctContext.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)
+                .emit(ReactNativeBlobUtilConst.EVENT_PROGRESS, args);
+    }
+
 }
